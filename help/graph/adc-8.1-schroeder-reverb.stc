// adc ; 8.1 ; http://www.audiosynth.com/files/SC2.2.16.sea.hqx
var input,			// audio input signal
	revMonoInput,		// reverb input must be mono for this version.
	buffer,			// a buffer for the early reflections delay line
	tapData,		// Early reflection tap data (times, levels)
	tapsOut, 		// sound output from the delay taps
	combData,	 	// Table of comb data (times, levels)
	combs,			// List of comb objects
	combsOut,		// their sound output
	allPassIo, 		// allPass chain sound input/output variable
	revTime,		// Global decay (time in seconds)
	revBalance,		// Dry/wet balance (ratio).
	tapScale,		// Tap amplitude scaling factor.
	combScale,		// Comb amplitude scaling factor.
	delayWriter;
tapData := [
	[0.0043,	0.841],
	[0.0215,	0.504],
	[0.0268,	0.379],
	[0.0298,	0.346],
	[0.0485,	0.272],
	[0.0572,	0.217],
	[0.0595,	0.192],
	[0.0708,	0.181],
	[0.0741,	0.142],
	[0.0797,	0.134]
];
combData := [
	[0.050,	0.46],
	[0.056,	0.48],
	[0.061,	0.50],
	[0.068,	0.52],
	[0.072,	0.53],
	[0.078,	0.55]
];
revTime := 3;
revBalance := 0.5;
tapScale := revBalance / tapData.size;
combScale := revBalance / combs.size;
input := 0.5.coin.ifTrue({
	Impulse(0.2, 2)
}, ifFalse: {
	Decay2(Impulse(0.2, 2), 0.001, 0.2) * PinkNoise()
});
buffer := BufAlloc(1, 48000 * 0.1).clearBuf;
revMonoInput := input.isKindOf(Array).ifTrue({
	input.sum / input.size
}, ifFalse:	{
	input
});
delayWriter := DelayWrite(buffer, revMonoInput);
tapsOut := 0;
tapData.do ({
	arg params;
	tapsOut := tapsOut + (DelayTap(buffer, params.first) * params.second);
});
combsOut := 0;
1.to(6).do({
	arg index;
	combsOut := combsOut + (
		CombC(
			revMonoInput + tapsOut, // tapsOut could be scaled
			0.1,
			combData[index].first,
			revTime
		) * combData.[index].second
	)
});
allPassIo := combsOut;
4.timesRepeat({
	allPassIo := AllpassN(
		allPassIo,
		0.050,
		[0.050.rand, 0.050.rand],
		1
)});
[
	[ input * (1 - revBalance), input * (1 - revBalance)],
	((tapsOut + allPassIo) * revBalance)
].sum.mrg(delayWriter)
