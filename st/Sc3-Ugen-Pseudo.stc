/* EnvGen of simplified EnvAdsr */
Adsr : PseudoUgen {
    *cons {
        arg gate = 1, attackTime = 0.01, decayTime = 0.3, sustainLevel = 0.5, releaseTime = 1, curves = -4;
        ^EnvAdsr(attackTime, decayTime, sustainLevel, releaseTime, 1, curves).asEnvGen(gate)
    }
}

/* EnvGen of simplified EnvAsr */
Asr : PseudoUgen {
    *cons {
        arg gate = 1, attackTime = 0.01, releaseTime = 1, curves = -4;
        ^EnvAsr(attackTime, 1, releaseTime, curves).asEnvGen(gate)
    }
}

/* Audio input */
AudioIn : PseudoUgen {
    *cons {
        arg channels;
        ^In(1, NumOutputBuses() + channels - 1)
    }
}

/* Allocate a buffer local to the synth */
BufAlloc : PseudoUgen {
    *cons {
        arg numChannels, numFrames;
        ^LocalBuf(numChannels, numFrames)
    }
}

/* Record signal into a Buffer */
BufRec : PseudoUgen {
    *cons {
        arg bufnum, reset, inputArray;
        ^RecordBuf(bufnum, 0, 1, 0, 1, 1, reset, 0, inputArray)
    }
}

/* Continuous controller input */
Cc : PseudoUgen {
    *cons {
        arg index;
        ^In(1, 11000 + index).kr
    }
}

/* Triggers when a value changes */
Changed : PseudoUgen {
    *cons {
        arg input, threshold;
        ^HPZ1(input).abs > threshold
    }
}

/* Random sequence generator */
Choose : PseudoUgen {
    *cons {
        arg repeats, list;
        ^Drand(repeats, list)
    }
}

/* Control input */
ControlIn : PseudoUgen {
    *cons {
        arg numChan, bus;
        ^In(numChan, bus).kr
    }
}

/* EnvGen of simple cutoff envelope */
Cutoff : PseudoUgen {
    *cons {
        arg sustainTime, releaseTime, curve;
        ^EnvSpec(#[1, 1, 0], [sustainTime, releaseTime], curve, nil, nil, 0).asEnvGen
    }
}

/* Demand with duration input (Duty) */
DmdFor : PseudoUgen {
    *cons {
        arg dur, reset, level;
        ^Duty(dur, reset, 0, level)
    }
}

/* Demand with trigger input (Demand) */
DmdOn : PseudoUgen {
    *cons {
        arg trig, reset, demandUGens;
        ^Demand(trig, reset, demandUGens)
    }
}

/* Dynamic klank, set of non-fixed resonating filters */
DynKlank : PseudoUgen {
    *cons {
        arg input, freqscale, freqoffset, decayscale, specificationsArrayRef;
        var gen;
        gen = {
            arg ix;
            var f = specificationsArrayRef.at(ix);
            var a = specificationsArrayRef.at(ix + 1);
            var d = specificationsArrayRef.at(ix + 2);
            Ringz(input, f * freqscale + freqoffset, d * decayscale) * a
        };
        ^1.to(specificationsArrayRef.size, by: 3).collect(gen).sum
    }
}

/* Dynamic parallel bank of Ringz */
DynRingzBank : PseudoUgen {
    *cons {
        arg input, freq, amp, time;
        ^DynKlank(input, 1, 0, 1, [freq, amp, time].asKlankSpec)
    }
}

/* Read signal from a bus with a current or one cycle old timestamp */
InFb : PseudoUgen {
    *cons {
        arg numChan, bus;
        ^InFeedback(numChan, bus)
    }
}

/* Key down control input for indicated voice (W) */
KeyDown : PseudoUgen {
    *cons {
        arg voiceNumber;
        ^ControlIn(1, Voicer.voiceAddr(voiceNumber) + 0)
    }
}

/* Key pitch control input for indicated voice */
KeyPitch : PseudoUgen {
    *cons {
        arg voiceNumber;
        ^ControlIn(1, Voicer.voiceAddr(voiceNumber) + 7)
    }
}

/* Key timbre control input for indicated voice (Y) */
KeyTimbre : PseudoUgen {
    *cons {
        arg voiceNumber;
        ^ControlIn(1, Voicer.voiceAddr(voiceNumber) + 2)
    }
}

/* Key velocity control input for indicated voice (Z) */
KeyVelocity : PseudoUgen {
    *cons {
        arg voiceNumber;
        ^ControlIn(1, Voicer.voiceAddr(voiceNumber) + 3)
    }
}

/* Map a linear range to a linear range */
LinLin : PseudoUgen {
    *cons {
        arg in, srclo, srchi, dstlo, dsthi;
        ^(in - srclo) / (srchi - srclo) * (dsthi - dstlo) + dstlo
    }
}

/* Line Segment Envelope */
LinSeg : PseudoUgen {
    *cons {
        arg gate, coord;
        var levels = 1.to(coord.size, by: 2).collect({ arg i; coord.at(i) });
        var times = 2.to(coord.size, by: 2).collect({ arg i; coord.at(i) });
        ^EnvSpec(levels, times, #['lin'], nil, nil, 0).asEnvGen(gate)
    }
}

/* Line generator */
Ln : PseudoUgen {
    *cons {
        arg start, end, dur;
        ^Line(start, end, dur, 0)
    }
}

/* An oscillator that reads through a table once */
Osc1 : PseudoUgen {
    *cons {
        arg bufnum, dur;
        var phase = Ln(0, BufFrames(bufnum) - 1, dur);
        ^BufRd(1, bufnum, phase, 0, 2)
    }
}

/* Texture generator */
OverlapTexture : PseudoUgen {
    *cons {
        arg graphFunc, sustainTime, transitionTime, overlap;
        var voiceFunc = {
            arg i;
            var t = Impulse(1 / (sustainTime + (transitionTime * 2)), i / overlap).kr;
            graphFunc(t) * EnvLinen(transitionTime, sustainTime, transitionTime, 1, 'sin').asEnvGen(t)
        };
        ^1.to(overlap, collect: voiceFunc).sum
    }
}

/* Pen angle */
PenAngle : PseudoUgen {
    *cons {
        arg voiceNumber;
        ^ControlIn(1, Voicer.voiceAddr(voiceNumber) + 4)
    }
}

/* Pen down (W) */
PenDown : PseudoUgen {
    *cons {
        arg voiceNumber;
        ^ControlIn(1, Voicer.voiceAddr(voiceNumber) + 0)
    }
}

/* Pen radius */
PenRadius : PseudoUgen {
    *cons {
        arg voiceNumber;
        ^ControlIn(1, Voicer.voiceAddr(voiceNumber) + 5)
    }
}

/* Pen X */
PenX : PseudoUgen {
    *cons {
        arg voiceNumber;
        ^ControlIn(1, Voicer.voiceAddr(voiceNumber) + 1)
    }
}

/* Pen Y */
PenY : PseudoUgen {
    *cons {
        arg voiceNumber;
        ^ControlIn(1, Voicer.voiceAddr(voiceNumber) + 2)
    }
}

/* Pen Z */
PenZ : PseudoUgen {
    *cons {
        arg voiceNumber;
        ^ControlIn(1, Voicer.voiceAddr(voiceNumber) + 3)
    }
}

/* Phase modulation sine oscillator pair */
PMOsc : PseudoUgen {
    *cons {
        arg carfreq, modfreq, pmindex, modphase;
        ^SinOsc(carfreq, SinOsc(modfreq, modphase) * pmindex)
    }
}

/* Parallel bank of Ringz */
RingzBank : PseudoUgen {
    *cons {
        arg input, freq, amp, time;
        ^Klank(input, 1, 0, 1, [freq, amp, time].asKlankSpec)
    }
}

/* Select one of two branches based on predicate signal */
Select2 : PseudoUgen {
    *cons {
        arg predicate, ifTrue, ifFalse;
        ^(predicate * (ifTrue - ifFalse)) + ifFalse
    }
}

/* Mix one output from many sources */
SelectX : PseudoUgen {
    *cons {
        arg which, array;
        ^XFade2(
            Select(which.roundTo(2), array),
            Select(which.truncateTo(2) + 1, array),
            (which * 2 - 1).fold2(1),
            1)
    }
}

/* Sequence generator */
Seq : PseudoUgen {
    *cons {
        arg repeats, list;
        ^Dseq(repeats, list)
    }
}

/* Demand rate arithmetic series Ugen */
Ser : PseudoUgen {
    *cons {
        arg repeats, list;
        ^Dser(repeats, list)
    }
}

/* Demand rate random sequence generator */
Shuf : PseudoUgen {
    *cons {
        arg repeats, list;
        ^Dshuf(repeats, list)
    }
}

/* Parallel bank of SinOsc */
SinOscBank : PseudoUgen {
    *cons {
        arg freq, amp, phase;
        ^Klang(1, 0, [freq, amp, phase].asKlangSpec)
    }
}

/* Pan an array of channels across the stereo field */
Splay : PseudoUgen {
    *cons {
        arg inArray, spread, level, center, levelComp;
		var n = 2.max(inArray.size);
		var n1 = n - 1;
		var pos = (0.to(n1) * (2 / n1) - 1) * spread + center;
        var lvl = levelComp.ifTrue({
            level * n.reciprocal.sqrt
		}, ifFalse: {
            level
        });
		^Pan2(inArray, pos, lvl).sum
	}
}

/* Pan an array of channels across the stereo field */
Splay2 : PseudoUgen {
    *cons {
        arg inArray;
        ^Splay(inArray, 1, 1, 0, true)
    }
}

/* Switch (maintained or momentary) controller input */
Sw : PseudoUgen {
    *cons {
        arg index;
        ^In(1, 12000 + index).kr
    }
}

/* Randomly select one of several inputs on trigger */
TChoose : PseudoUgen {
    *cons {
        arg trig, array;
        ^Select(TIRand(0, array.size - 1, trig), array)
    }
}

/* Demand with duration input (TDuty) */
TDmdFor : PseudoUgen {
    *cons {
        arg dur, reset, level;
        ^TDuty(dur, reset, 0, level, 0)
    }
}

/* Triggered Line */
TLine : PseudoUgen {
    *cons {
        arg start, end, dur, trig;
        ^EnvSpec([start, start, end], [0, dur], #['lin', 'lin'], -1, -1, 0).asEnvGen(trig)
    }
}

/* Trig1 with duration of one sample */
Tr1 : PseudoUgen {
    *cons {
        arg in;
        ^Trig1(in, SampleDur())
    }
}

/* Trig with duration of one sample */
Tr : PseudoUgen {
    *cons {
        arg in;
        ^Trig(in, SampleDur()) // Should be SampleDur if audio rate and ControlDur if control rate, requires QuantaDur or some such
    }
}

/* Triggered XLine */
TXLine : PseudoUgen {
    *cons {
        arg start, end, dur, trig;
        ^EnvSpec([start, start, end], [0, dur], #['exp', 'exp'], -1, -1, 0).asEnvGen(trig)
    }
}

WrapOut : PseudoUgen {
    *cons {
        arg bus, channelsArray;
        channelsArray.isArray.not.and({ channelsArray.isOutUgen }).ifTrue({
            ^channelsArray
        }, ifFalse: {
            ^Out(bus, channelsArray)
        })
    }
}

/* Line generator */
XLn : PseudoUgen {
    *cons {
        arg start, end, dur;
        ^XLine(start, end, dur, 0)
    }
}
